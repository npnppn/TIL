# 자바 ORM 표준 JPA 프로그래밍 (김영한) 교재를 보며 공부한 내용 정리

# JPA를 공부하기에 앞서..

# 그래서 왜 JPA를 사용해야하는데?

1) 생산성

JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 된다. 지루하고 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 되니까 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다!

2) 유지보수

SQL을 직접 다루면 엔티티에 필드를 하나만 추가해도 관련된 등록,  수정, 조회 SQL과 결과를 매핑하기 위한 JDBC API코드를 모두 변경해야한다. 하지만 JPA를 사용하면 이런 과정을 JPA가 대신 처리해주므로 유지보수해야 하는 코드 수가 줄어든다.

3) 패러다임의 불일치 해결

JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.

→ JPA가 패러다임의 불일치 문제를 해결해주므로 객체지향 언어가 가진 장점을 활용해서 유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있다!

4) 성능

애플리케이션과 데이터베이스 사이에서 동작하니 다양한 성능 최적화 기회를 제공한다.

5) 데이터 접근 추상화와 벤더 독립성

# ORM과 마이바티스와 차이?

마이바티스나 스프링 JDBCTEMPLATE을 보통 SQL 매퍼라고 하는데 이는 결국 개발자가 SQL을 직접 작성해야하므로 SQL에 의존하는 개발을 해야한다. 하지만 ORM은 객체와 테이블을 매핑만하면 ORM프레임워크가 SQL을 만들어서 데이터베이스 관련 처리르 해주므로 SQL에 의존하는 개발을 피할 수 있다.  

## 무슨 공부를 하던 왜 이 기술을 사용해야하는지에 대해 알아야하는게 중요하다고 생각!!

---

# 1장. JPA 소개

### 애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점

- 계층 분할이 어렵다
- 엔티티를 신뢰할 수 없다
- SQL에 의존적인 개발을 피하기 어렵다

### 객체와 RDB 사이의 패러다임 불일치 문제

- 상속
- 연관관계
    - 객체는 참조를 이용, 테이블은 외래키를 이용
- 객체 그래프 탐색
    - 객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다
    - SQL을 직접 다루면 처음 실행하는 sql에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다
    - 그렇다고 연관된 모든 객체 그래프를 조회해 메모리에 올려 두는 것은 현실성 없다
    - JPA는 연관 객체를 사용하는 시점에 적절한 SELECT문을 실행해, 연관된 객체를 신뢰하고 마음껏 조회할 수 있다
- 비교
    - 동등성, 동일성
        - 동일성, Identity - 실제 인스턴스가 같다. ==
        - 동등성, Equality - 실제 인스턴스는 다를 수 있으나, 갖고 있는 값이 같다. equals()


### JPA란

- **JPA는 자바 ORM 기술에 대한 API 표준 명세**
- 대표적인 구현체로 Hibernate
- 통계 쿼리 같이 복잡한 쿼리보단, 실시간 처리용 쿼리에 더 최적화되어 있다
- JPA가 어려운 이유 : ORM은 OOP와 RDB 둘다 잘 이해해야 하기 때문
- JPA를 사용해야 하는 이유
    - 생산성
    - 유지보수성
    - 패러다임의 불일치 해결
    - 성능
        - 애플리케이션과 데이터베이스 사이에 계층이 하나 더 있으면, 성능 관점에서 시도해 볼 수 있는 것들이 많다.
        - 대표적으로 영속성 컨텍스트를 활용해, 쿼리를 두번 보내지 않고 조회한 객체 재사용 가능
    - 데이터 접근 추상화와 벤더 독립성
        - 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해, 특정 DB 기술에 종속되지 않도록 해준다
    - 표준

# 2장. JPA 시작

- H2
    - H2는 JVM 메모리 안에서 실행되는 **임베디드 모드**와, 실제 DB처럼 별도의 서버를 띄워 동작하는 **서버 모드**가 있다.

- Dialect 방언
    - `org.hibernate.dialect.H2Dialect`
    - `org.hibernate.dialect.MySQL5InnoDBDialect`

### JPQL

- JPQL은 엔티티 객체를 대상으로 쿼리 vs SQL은 DB 테이블을 대상으로 쿼리한다
- JPQL은 DB 테이블을 전혀 알지 못한다
- JPA는 JPQL을 분석해 적절한 SQL을 만들어 DB에서 데이터를 조회한다

# 3장. 영속성 관리

### EntityManagerFactory - EntityManager - Persistence Context

- 엔티티 매니저 팩토리
    - 설정 정보를 활용해 만들어진다
    - 앤티티 매니저를 만드는 곳이며, 생성 비용이 커 애플리케이션 전체에서 하나만 만들어 공유한다
    - ***여러 스레드가 동시에 접근 및 공유 가능***
- 엔티티 매니저
    - JPA 기능 대부분을 제공
    - 내부에 데이터소스(커넥션)를 유지하며 DB와 통신
        - 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다
        - 예를 들어, 트랜잭션을 시작할 때 커넥션 획득
    - 커넥션과 밀접한 관계가 있으므로, ***스레드간에 공유되거나 재사용하면 안된다***
- 영속성 컨텍스트
    - 엔티티를 영구 저장하는 환경 (직역..), 논리적 개념
    - 여러 엔티티 매니저가 한 영속성 컨텍스트에 접근할 수 있으나, 일단 지금은 1:1로 생각, 복잡한 상황은 11장 참고

### 엔티티의 생명주기

- 비영속
- 영속
    - 영속 상태 - 엔티티가 영속성 컨텍스트에 의해 관리되는 상태
    - ex
        - em.persist()는 엔티티를 영속성 컨텍스트에 저장한다
        - em.find() or JPQL로 조회한 엔티티도 영속 상태
- 준영속
    - 준영속으로 만드는 3가지 방법
        - em.detach()에 의해 (삭제까진 아니고) 더이상 관리되지 않는 상태
        - em.close() or em.clear()로 영속성 컨텍스트를 닫거나 초기화해도, 관리되던 엔티티들은 준영속 상태가 된다
    - 준영속의 특징 & 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다
        - 거의 비영속 상태에 가깝다
        - 식별자 값을 갖고 있다. (한번 영속됬으므로, 비영속은 식별자 값이 없을 수 도 있음)
        - 지연 로딩을 할 수 없다
- 삭제

### 영속성 컨텍스트의 특징

- 엔티티를 식별자로 구분한다. 따라서 영속상태는 반드시 식별자 값(@Id로, PK와 매핑되는 값)이 있어야 한다.
- Flush : 트랜잭션을 커밋하는 순간, 영속성 컨텍스트의 변경내용을 DB와 동기화
- 장점
    - 1차 캐시
        - Map
        - JPA는 1차 캐시를 통해, 'REPEATABLE READ 등급의 트랜잭션 격리 수준'을 DB가 아닌 애플리케이션 레벨에서 제공한다는 장점이 있다.
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지, Dirty Checking
        - JPA는 엔티티를 영속성 컨텍스트에 저장할 때, 최초 상태를 복사해 저장한다. (스냅샷) 그리고 플러시 시점에 스냅샷과 엔티티를 비교
        - 변경 감지는 영속 상태의 엔티티에만 적용된다
        - 주의 - ***JPA의 기본 전략은, 엔티티의 모든 필드를 업데이트 한다***
            - 단점 - DB에 보내는 데이터 양이 증가
            - 장점 - 수정 쿼리가 항상 같아, 애플리케이션 로딩시 미리 생성해두고 재사용할 수 있다. DB도 이전에 한번 파싱한 쿼리를 재사용할 수 있다.
            - `@DynamicUpdate`, `@DynamicInsert` (Hibernate)
                - 필드나 저장 데이터가 너무! 많으면 본 애노테이션을 이용해, 동적으로 쿼리를 생성하는 전략을 택한다.
                - 보통 컬럼이 30개 이상 되면 기본 정적 쿼리보다 동적 쿼리가 빠르다고 한다.
                - 하지만, 한 테이블에 컬럼이 30개 이상 된다는 건, 설계상 책임이 적절히 분리되지 않았을 가능성이 높다.
    - 지연 로딩

### 플러시, Flush

- 영속성 컨텍스트의 변경 내용을 DB에 반영
- 영속성 컨텍스트를 플러시하는 3가지 방법
    - em.flush() 직접 호출
    - 트랜잭션 커밋시, 자동 호출
    - JPQL 쿼리 실행시, 자동 호출

        ```sql
        em.persist(memberA);

        query = em.createQuery("SELECT m FROM Member m", Member.class);
        List<Member> members = query.getResultList();
        ```

        - 이 상황에서 memberA는 영속성 컨텍스트엔 있지만 DB엔 아직 반영되지 않았다.
        - JPQL은 sql로 변환되어 DB에서 엔티티를 조회하는데, 아직 memberA가 DB에 없어 조회되지 않을 것이다.
        - 이런 문제를 예방하기 위해, JPQL을 실행할 때도 플러시를 자동 호출한다.

      
        - *Criteria, QueryDSL은 결국 JPQL을 편리하게 사용하기 위한 기술*
- FlushModeType.~로 모드 설정 가능
- 오해 - 이름만 보고 Flush를 '데이터를 지우는 것'으로 오해하지 말 것

### 병합, merge()

- 엔티티를 받아, 새로운 영속 상태의 엔티티를 반환
- merge는 준영속, 비영속을 신경 쓰지 않는다
    - 식별자 값으로 엔티티 조회되면 찾아 병합하고, 조회 안되면 새로 생성해 병합한다
    - 따라서 병합은 save or update 기능을 수행한다

# 4장. 엔티티 매핑

### 주의사항

- @Entity - 인자 없는 기본 생성자 필수
- @Table(uniqueConstraints=?), @Column(length=?, nullable=?) 등과 같은 *제약 조건들은 DDL을 통한 자동 생성시에만 적용*되고, JPA 실행 로직엔 영향을 주지 않는다.
    - 따라서 스키마 자동 생성 기능을 사용하지 않고, 직접 DDL을 만든다면 사용할 필요는 없다
    - 하지만 애플리케이션 개발자가 보고 알수있도록 *명시용*으로 쓸 수 있다

### 스키마 자동 생성 기능

- [hibernate.hbm2ddl.auto](http://hibernate.hbm2ddl.auto) 속성
    - create
    - create-drop
    - update
    - validate
    - none
- 운영 환경에선 create, create-drop, update와 같은 DDL을 수정하는 옵션을 사용해선 안된다. validate 추천
- 위의 속성들은 hibernate꺼다. JPA도 2.1부터 스키마 자동 생성 기능을 지원하는데, update와 validate는 안된다

### Naming Strategy

- 자바는 카멜 케이스, 데이터베이스는 언더스코어가 관례
- `hibernate.ejb.naming_strategy` 속성을 사용해, 이름 매핑 전략을 설정 가능
- 하이버네이트는 `org.hibernate.cfg.ImprovedNamingStrategy` 클래스를 제공
    - 테이블명, 컬럼명이 생략되면 자바의 카멜 표기법을 테이블의 언더스코어 표기법으로 매핑
